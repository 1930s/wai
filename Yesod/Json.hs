-- | Efficient generation of JSON documents, with HTML-entity encoding handled via types.
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE CPP #-}
module Yesod.Json
    ( -- * Monad
      Json
    , jsonToContent
    , jsonToRepJson
      -- * Generate Json output
    , jsonScalar
    , jsonList
    , jsonMap
#if TEST
    , testSuite
#endif
    )
    where

import Text.Hamlet.Monad
import qualified Data.ByteString.Char8 as S8
import Data.Char (isControl)
import Yesod.Hamlet
import Yesod.Handler
import Web.Routes.Quasi (Routes)
import Numeric (showHex)
import Data.Monoid (Monoid (..))
import Data.Convertible.Text (cs)

#if TEST
import Test.Framework (testGroup, Test)
import Test.Framework.Providers.HUnit
import Test.HUnit hiding (Test)
import Data.Text.Lazy (unpack)
import Yesod.Content hiding (testSuite)
#else
import Yesod.Content
#endif

-- | A monad for generating Json output. In truth, it is just a newtype wrapper
-- around 'Hamlet'; we thereby get the benefits of Hamlet (interleaving IO and
-- enumerator output) without accidently mixing non-JSON content.
--
-- This is an opaque type to avoid any possible insertion of non-JSON content.
-- Due to the limited nature of the JSON format, you can create any valid JSON
-- document you wish using only 'jsonScalar', 'jsonList' and 'jsonMap'.
newtype Json url = Json { unJson :: Hamlet url }
    deriving Monoid

-- | Extract the final result from the given 'Json' value.
--
-- See also: applyLayoutJson in "Yesod.Yesod".
jsonToContent :: Json (Routes master) -> GHandler sub master Content
jsonToContent = hamletToContent . unJson

-- | Wraps the 'Content' generated by 'jsonToContent' in a 'RepJson'.
jsonToRepJson :: Json (Routes master) -> GHandler sub master RepJson
jsonToRepJson = fmap RepJson . jsonToContent

-- | Outputs a single scalar. This function essentially:
--
-- * Performs HTML entity escaping as necesary.
--
-- * Performs JSON encoding.
--
-- * Wraps the resulting string in quotes.
jsonScalar :: HtmlContent -> Json url
jsonScalar s = Json $ mconcat
    [ outputString "\""
    , output $ encodeJson $ htmlContentToByteString s
    , outputString "\""
    ]
  where
    encodeJson = S8.concatMap (S8.pack . encodeJsonChar)

    encodeJsonChar '\b' = "\\b"
    encodeJsonChar '\f' = "\\f"
    encodeJsonChar '\n' = "\\n"
    encodeJsonChar '\r' = "\\r"
    encodeJsonChar '\t' = "\\t"
    encodeJsonChar '"' = "\\\""
    encodeJsonChar '\\' = "\\\\"
    encodeJsonChar c
        | not $ isControl c = [c]
        | c < '\x10'   = '\\' : 'u' : '0' : '0' : '0' : hexxs
        | c < '\x100'  = '\\' : 'u' : '0' : '0' : hexxs
        | c < '\x1000' = '\\' : 'u' : '0' : hexxs
        where hexxs = showHex (fromEnum c) ""
    encodeJsonChar c = [c]

-- | Outputs a JSON list, eg [\"foo\",\"bar\",\"baz\"].
jsonList :: [Json url] -> Json url
jsonList [] = Json $ outputOctets "[]"
jsonList (x:xs) = mconcat
    [ Json $ outputOctets "["
    , x
    , mconcat $ map go xs
    , Json $ outputOctets "]"
    ]
  where
    go j = mappend (Json $ outputOctets ",") j

-- | Outputs a JSON map, eg {\"foo\":\"bar\",\"baz\":\"bin\"}.
jsonMap :: [(String, Json url)] -> Json url
jsonMap [] = Json $ outputOctets "{}"
jsonMap (x:xs) = mconcat
    [ Json $ outputOctets "{"
    , go x
    , mconcat $ map go' xs
    , Json $ outputOctets "}"
    ]
  where
    go' y = mappend (Json $ outputOctets ",") $ go y
    go (k, v) = mconcat
        [ jsonScalar $ Unencoded $ cs k
        , Json $ outputOctets ":"
        , v
        ]

#if TEST

testSuite :: Test
testSuite = testGroup "Yesod.Json"
    [ testCase "simple output" caseSimpleOutput
    ]

caseSimpleOutput :: Assertion
caseSimpleOutput = do
    let j = do
        jsonMap
            [ ("foo" , jsonList
                [ jsonScalar $ Encoded $ pack "bar"
                , jsonScalar $ Encoded $ pack "baz"
                ])
            ]
    t <- hamletToText id $ unJson j
    "{\"foo\":[\"bar\",\"baz\"]}" @=? unpack t

#endif
